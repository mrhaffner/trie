<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="upgrade-insecure-requests"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
    />
    <title>Trie</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{{ url_for('static', filename='apple-touch-icon.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{{ url_for('static', filename='favicon-32x32.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{{ url_for('static', filename='favicon-16x16.png') }}"
    />
    <link
      rel="manifest"
      href="{{ url_for('static', filename='site.webmanifest') }}"
    />
  </head>
  <body>
    <div id="content-wrapper">
      <header>
        <h1>Implementing Autocomplete with Trie</h1>
        <p>By Matt Haffner</p>
        <p>
          <a href="https://github.com/mrhaffner/trie">Project Repository</a>
        </p>
      </header>
      <section>
        <h2>A Basic Trie</h2>
        <div>
          <p>
            Selecting an efficient method to find autocomplete suggestions
            presents a unique challenge. This challenge is efficiently handled
            with a Trie a.k.a. Prefix Tree. A Trie is a specialized tree where
            each child node represents a character.
          </p>
          <p>
            A word in the Trie is indicated by following a path from the root to
            a node that is marked as being the end of a word. The location of a
            child node on its parent node's edges is used to determine what
            character the child node represents with a hash function. A null
            pointer indicates no children exist in the Trie for that given
            character.
          </p>
          <p>
            Due to the large number of edges, representing a Trie visually can
            be space intensize. Consider a Trie with a character set containing
            only the letters "a", "b" and "c". "a" hashes to index 0, "b" to 1
            and "c" to 2. This Trie contains the suffixes: "a", "abc" and "ca".
            The root node represents the empty string which all Tries will
            contain by default. Witness this Trie:
          </p>
          <div class="image-container">
            <img
              src="{{ url_for('static', filename='trie.jpg') }}"
              alt="A Trie"
            />
            <figcaption>A Trie with a small character set</figcaption>
          </div>
          <p>
            We want to use this Trie to get autocomplete suggestions for the
            prefix "a". We start by navigating to the "a" node. We will then
            perform a depth first search on all child nodes. As we search, we
            add the character value of the next node until we reach a node
            marked as the end of a valid suffix. We then add this word to the
            output. Since "a" itself is a valid suffix represented as the empty
            string, the output is: ["", "bc"]. Depending on our autocomplete
            implementation, we could merge this result with the given prefix to
            give: ["a", "abc"].
          </p>
          <p>
            If we were to perform a search on the Trie with the prefix "", we
            would get as a result all valid suffixes in the Trie. In this case,
            we choose to ignore the root of the Trie as a result. We get: ["a",
            "abc", "ca"]. Note that our results appear in alphabetical order -
            ie in the order they are hashed.
          </p>
          <p>
            We can see a simple implementation with the following search bar:
          </p>
        </div>
        <div class="search-container">
          <form id="trie-form">
            <div id="trie-search-bar" class="search-bar">
              <input
                id="search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          This implementation is efficient. Suggestions are found in
          O(P+H&times;C&times;N) time. "P" represents the length of the prefix
          that we are trying to get suggestions for. "H" represents the height
          of the subtree we are trying to get suggestions from. This is the
          length of the longest suffix in the subtree. "C" represents the
          character set the Trie supports. "N" represents the number of paths
          from the root node of our subtree to all of its leaves. "N" is not the
          same as the number of suffixes in the subtree as suffixes may overlap.
        </p>
        <p>
          In our implementation, all of the variables are constants. We will
          however, give big O notations as if they weren not. It is not
          neccesary to support strings of a potentially unlimited length. Most
          searches are short, so we can set a reasonable max height for our
          Trie. In our implementation, we chose 200 for the max length of a word
          in the Trie. This max length limits length of "P" and "H".
        </p>
        <p>
          Our character set, "C", is 26 English letters + 1 space character =
          27. "N" is also technically limited by the max height of the trie.
          Deletions and insertions are done in O(S) time. "S" is the length of
          the suffix which is at most the max height of the Trie. This become
          O(1).
        </p>
        <p>
          The main drawback of the Trie is the large amount of memory that is
          used. Every node has a number of children equal to the size of the
          character set. Generally, most of the children of a given node will be
          null pointers. The maximum size of a Trie is
          (C<sup>(H+1)</sup>-1)/(C-1). For our implementation, C=27 and H=200
          which gives us a maximum size of 1.9&times;10<sup>286</sup> nodes.
          That is a very large constant. Without a fixed height or character
          set, the size of a Trie is O(C<sup>H</sup>).
        </p>
        <p>
          The Trie will find all suggestions for our given prefix. We will need
          to limit the suggestions we show. One feature of the Trie is that all
          suggestions will be ouput in alphabetical order. Alphabetical order is
          not likely the most relevant. But how do we choose which suggestions
          to show?
        </p>
      </section>
      <section>
        <h2>A Weighted Trie</h2>
        <p>
          We can make some simple modifications to our Trie to add a weight to
          each suffix. People will generally be looking for the most commonly
          searched terms. Therefore, the weight of a node will represent how
          often that term has appeared in searches.
        </p>
        <p>
          The new weight property will also serve to determine if a node is the
          end of a suffix. Nodes with a weight 1 or greater represent the end of
          a suffix.
        </p>
        <p>Try the new search bar and compare the results from the original:</p>
        <div class="search-container">
          <form id="trie-weighted-form">
            <div id="trie-weighted-search-bar" class="search-bar">
              <input
                id="weighted-search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="weighted-suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          We see that suggestions are now sorted in descending order based on
          weight. This Weighted Trie acts almost identically to the original
          Trie, except now results will be sorted.
        </p>
        <p>
          Sorting our suggestions does slow down retrieval. We use Timsort - the
          default sorting algorithm in Python. Timsort is a good choice because
          the algorithm is stable. This means that it will automatically keep
          the previously existing alphabetical ordering after sorting by weight
          for items of equal weight.
        </p>
        <p>
          Timsort operates in O(N&times;log(N)) time. "N" represents the number
          of suffixes that match our prefix. The number of suffixes found is
          limited by the maximum number of nodes that our Trie may contain. The
          preformance hit is well worth the benefit of drastically enhanced user
          experience.
        </p>
        <p>
          Now that our Trie is showing more relevant suggestions, what can we do
          to improve performance?
        </p>
      </section>
      <section>
        <h2>A Cached Trie</h2>
        <p>
          Traversing the entire subtree from the end of a given prefix everytime
          we want suggestions is undesirable. We can significantly improve
          performance by generating a cache of suggestions for every node in the
          Trie.
        </p>
        <p>Suggestions are now found in O(S) time. Try our new search bar:</p>
        <div class="search-container">
          <form id="trie-cached-form">
            <div id="trie-cached-search-bar" class="search-bar">
              <input
                id="cached-search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="cached-suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          Creating a cache for every node will amplify memory use. Fortunately,
          it is not neccesary to store a potentially unlimited sized cache. This
          increases our memory usage by a small constant: "L".
        </p>
        <p>
          Caching also creates a performance trade off. Insertions and deletions
          from the Trie will now need to update the cache for every affected
          node. For every character in the suffix, we will need to gather all
          valid suffixes, sort and truncate them. What took place in O(S) time
          now takes O(S&times;H&times;C&times;N&times;L&times;log(L)) time. This
          represents a significant performance hit.
        </p>
        <p>
          To give you an idea of the performance hit. We insert 5,334 scraped
          suggestions into all three Tries. The original Trie takes 0.08 seconds
          to insert all entries. The Weighted Trie takes 0.10 seconds. While I
          am writing this, I am still waiting on the Cached Trie to finish...
          The Cached Trie took 173.57 seconds. That is 1735.7 times slower!
        </p>
        <p>
          Insertions and deletions will generally be rare outside of building
          the Trie. Depending on your implementation, they may only occur when
          originally building the Trie. Updates may be performed with a complete
          rebuild.
        </p>
        <p>
          In our implementation, we only use insertions to build the Trie and
          deletions never at all (we have left an exposed API to tinker around
          with insertions and deletions).
        </p>
        <p>
          In a real life system, the trie acts as an efficient interface to get
          search results. You would not use the trie itself to store searches in
          real time. A history of all searches, the number of times they were
          searched, and other data would be stored seperately. Based on this
          data, you could filter out innapropriate suggestions, calculate
          weights, and then build your trie. The trie itself could be stored in
          an in-memory database like Redis.
        </p>
      </section>
      <section>
        <h2>A Study of Google Autocomplete</h2>
        <p>
          We can use Google as a gold standard for a websearch autocomplete. Let
          us look at the results of a few different searches from different
          starting conditions.
        </p>
        <p>
          With a clear search history and not logged into a Google account we
          click on the searchbar:
        </p>
        <div class="image-container search-img-container">
          <img
            src="{{ url_for('static', filename='blank-no-history.jpg') }}"
            alt="Google trending search results"
          />
          <figcaption>Trending searches</figcaption>
        </div>
        <p>
          With no history to draw from, Google decideds to show us the current
          trending search results. This brings up a question on search weight.
          How does Google actually calculate the weight of a suggestion? We used
          hits in our implementaion, but Google likely includes trending data
          when calculating weight.
        </p>
        <p>
          Now we click on the searchbar with a history of typing "app" into the
          searchbar:
        </p>
        <div class="image-container search-img-container">
          <img
            src="{{ url_for('static', filename='blank-with-history.jpg') }}"
            alt="Google search results with history"
          />
          <figcaption>Searches based on history without input</figcaption>
        </div>
        <p>
          Our suggestions are now based on our previous search. Notice the
          results are not based purely on the prefix "app", but appear to based
          on what people clicked on after searching for "app".
        </p>
        <p>
          We now look at what happens when we type "app" into search without
          being logged in:
        </p>
        <div class="image-container search-img-container">
          <img
            src="{{ url_for('static', filename='app-original.jpg') }}"
            alt="Google search results for 'app'"
          />
          <figcaption>Search results for "app"</figcaption>
        </div>
        <p>
          These search results look a lot more familiar to our implementation.
          The one difference is the results are based on location. Does Google
          keep a different search set for every city? Probably not. Google most
          certainly has different data sets for different regions, but likely
          not at the city level. Notice that the city results appear right after
          "near me". The city data is probably being added after getting the
          first set of search suggestions.
        </p>
        <p>
          What happens when we type in a prefix with no matching suffixes? Let's
          try "appp":
        </p>
        <div class="image-container search-img-container">
          <img
            src="{{ url_for('static', filename='appp.jpg') }}"
            alt="Google search results for 'appp'"
          />
          <figcaption>Search results for "appp"</figcaption>
        </div>
        <p>
          The results are the same as for "app". This shows a new feature of the
          trie: spellchecking. In this case, we navigate down to the node
          representing the last "p" in "appp". This node has no valid suffixes.
          So, we use the suffixes of the closest ancestor node with valid
          suffixes.
        </p>
        <p>
          Spellchecking is best accomplished with a cached trie. If we were to
          use a non-cached trie, we would need to generate a list of valid
          suffixes at every character node in the prefix.
        </p>
        <p>
          Let us now look at the result of searching for "app" while logged into
          a Google account with previous search history.
        </p>
        <div class="image-container search-img-container">
          <img
            src="{{ url_for('static', filename='app-logged-in.jpg') }}"
            alt="Google search results for 'app' while logged in"
          />
          <figcaption>Search results for "app" while logged in</figcaption>
        </div>
        <p>
          You will notice a few changes here. Google now appends a list of our
          previous searches that match the prefix. This could be handled with a
          seperate trie for our search history. This trie could be weighted
          based on how long ago the searches were made. We would want to include
          recent searches, but probably not searches from 5 years ago.
        </p>
        <p>
          The other results are also different. This is likely due to a
          differing search history. Again, suggesting that our history is part
          of the weight calculation. This could potentially be done with a per
          user trie.
        </p>
        <p>
          So does Google use the Trie for its autocomplete? I have no idea. What
          I can tell you is that the there is a lot more going on under the hood
          than our simple implementation.
        </p>
      </section>
    </div>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
