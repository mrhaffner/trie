<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="upgrade-insecure-requests"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
    />
    <title>Trie</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{{ url_for('static', filename='apple-touch-icon.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{{ url_for('static', filename='favicon-32x32.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{{ url_for('static', filename='favicon-16x16.png') }}"
    />
    <link
      rel="manifest"
      href="{{ url_for('static', filename='site.webmanifest') }}"
    />
  </head>
  <body>
    <div id="content-wrapper">
      <header>
        <h1>Implementing Autocomplete with Trie</h1>
        <p>By Matt Haffner</p>
        <p>
          <a href="https://github.com/mrhaffner/trie">Project Repository</a>
        </p>
      </header>
      <section>
        <h2>A Basic Trie</h2>
        <div>
          <p>
            Selecting an efficient method to find search suggestions presents a
            unique challenge. This challenge is efficiently handled with a Trie
            a.k.a. Prefix Tree. A Trie is a specialized tree where each child
            node represents a character.
          </p>
          <p>
            A word in the Trie is indicated by following a path from the root to
            a node that is marked as being the end of a word. The location of a
            child node on its parent node's edges is used to determine what
            character the child node represents with a hash function. A null
            pointer indicates no children exist in the Trie for that given
            character.
          </p>
          <p>
            Due to the large number of edges, representing a Trie visually can
            be space intensize. Consider a Trie with a character set containing
            only the letters "a", "b" and "c". "a" hashes to index 0, "b" to 1
            and "c" to 2. This Trie contains the suffixes: "a", "abc" and "ca".
            The root node represents the empty string which all Tries will
            contain by default. Witness this Trie:
          </p>
          <div class="image-container">
            <img
              src="{{ url_for('static', filename='trie.jpg') }}"
              alt="A Trie"
            />
            <figcaption>A Trie with a small character set</figcaption>
          </div>
          <p>
            We want to use this Trie to get autocomplete suggestions for the
            prefix "a". We start by navigating to the "a" node. We will then
            perform a depth first search on all child nodes. As we search, we
            add the character value of the next node until we reach a node
            marked as the end of a valid suffix. We then add this word to the
            output. Since "a" itself is a valid suffix represented as the empty
            string, the output is: ["", "bc"]. Depending on our autocomplete
            implementation, we could merge this result with the given prefix to
            give: ["a", "abc"].
          </p>
          <p>
            If we were to perform a search on the Trie with the prefix "", we
            would get as a result all valid suffixes in the Trie. In this case,
            we choose to ignore the root of the Trie as a result. We get: ["a",
            "abc", "ca"]. Note that our results appear in alphabetical order -
            ie in the order they are hashed.
          </p>
          <p>
            We can see a simple implementation with the following search bar:
          </p>
        </div>
        <div class="search-container">
          <form id="trie-form">
            <div id="trie-search-bar" class="search-bar">
              <input
                id="search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          This implementation is efficient. Suggestions are found in
          O(P+H&times;C&times;N) time. "P" represents the length of the prefix
          that we are trying to get suggestions for. "H" represents the height
          of the subtree we are trying to get suggestions from. This is the
          length of the longest suffix in the subtree. "C" represents the
          character set the Trie supports. Our character set is 26 English
          letters + 1 space character = 27. "N" represents the number of
          suffixes the subtree contains.
        </p>
        <p>
          It is not neccesary to support strings of a potentially unlimited
          length. Most searches are short, so we can set a reasonable max height
          for our Trie. In our implementation, we chose 200 for the max length
          of a word in the Trie. Since "P", "H" and "C" are constants,
          retrieving autocomplete suggestions is done in O(N) time. "N" is also
          technically limited by the max size of the trie. Deletions and
          insertions are done in O(S). "S" is the length of the suffix which is
          at most the max height of the Trie. This become O(1).
        </p>
        <p>
          The main drawback of the Trie is the large amount of memory that is
          used. Every node has a number of children equal to the size of the
          character set. Generally, most of the children of a given node will be
          null pointers. The maximum size of a Trie is
          (C<sup>(H+1)</sup>-1)/(C-1). For our implementation, C=27 and H=200
          which gives us a maximum size of 1.9&times;10<sup>286</sup> nodes.
          That is a very large constant. Without a fixed height or character
          set, the size of a Trie is O(C<sup>H</sup>).
        </p>
        <p>
          The Trie will find all suggestions for our given prefix. We will need
          to limit the suggestions we show. One feature of the Trie is that all
          suggestions will be ouput in alphabetical order. Alphabetical order is
          not likely the most relevant. But how do we choose which suggestions
          to show?
        </p>
      </section>
      <section>
        <h2>A Weighted Trie</h2>
        <p>
          We can make some simple modifications to our Trie to add a weight to
          each suffix. People will generally be looking for the most commonly
          searched terms. Therefore, the weight of a node will represent how
          often that term has appeared in searches.
        </p>
        <p>
          The new weight property will also serve to determine if a node is the
          end of a suffix. Nodes with a weight 1 or greater represent the end of
          a suffix.
        </p>
        <p>Try the new search bar and compare the results from the original:</p>
        <div class="search-container">
          <form id="trie-weighted-form">
            <div id="trie-weighted-search-bar" class="search-bar">
              <input
                id="weighted-search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="weighted-suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          We see that suggestions are now sorted in descending order based on
          weight. This Weighted Trie acts almost identically to the original
          Trie, except now results will be sorted.
        </p>
        <p>
          Sorting our suggestions does slow down retrieval. We use Timsort - the
          default sorting algorithm in Python. Timsort is a good choice because
          the algorithm is stable. This means that it will automatically keep
          the previously existing alphabetical ordering after sorting by weight
          for items of equal weight.
        </p>
        <p>
          Timsort operates in O(N log N) time. "N" represents the number of
          suffixes that match our prefix. The number of suffixes found is
          limited by the maximum number of nodes that our Trie may contain. The
          preformance hit is well worth the benefit of drastically enhanced user
          experience.
        </p>
        <p>
          We have made one adjustment to sorting by weight. If a search prefix
          is itself a valid result, that result will always appear at the top of
          the results. Depending on your use case, this may or may not be a good
          choice. Google does not do this.
        </p>
        <p>
          Now that our Trie is showing more relevant suggestions. What can we do
          to improve performance? Stay tuned to find out!
        </p>
      </section>
    </div>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
