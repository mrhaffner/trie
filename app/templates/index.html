<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="upgrade-insecure-requests"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
    />
    <title>Trie</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{{ url_for('static', filename='apple-touch-icon.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{{ url_for('static', filename='favicon-32x32.png') }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{{ url_for('static', filename='favicon-16x16.png') }}"
    />
    <link
      rel="manifest"
      href="{{ url_for('static', filename='site.webmanifest') }}"
    />
  </head>
  <body>
    <div id="content-wrapper">
      <header>
        <h1>Implementing Autocomplete with Trie</h1>
        <p>By Matt Haffner</p>
        <p>
          <a href="https://github.com/mrhaffner/trie">Project Repository</a>
        </p>
      </header>
      <section>
        <h2>A Basic Trie</h2>
        <div>
          <p>
            Selecting an efficient method to find search suggestions presents a
            unique challenge. This challenge is efficiently handled with a Trie
            a.k.a. Prefix Tree. A Trie is a specialized tree where each child
            node represents a character.
          </p>
          <p>
            A word in the Trie is indicated by following a path from the root to
            a node that is marked as being the end of a word. The location of a
            child node on its parent node's edges is used to determine what
            character the child node represents with a hash function. A null
            pointer indicates no children exist in the Trie for that given
            character.
          </p>
          <p>
            Due to the large number of edges, representing a Trie visually can
            be space intensize. Consider a Trie with a character set containing
            only the letters "a", "b" and "c". "a" hashes to index 0, "b" to 1
            and "c" to 2. This Trie contains the suffixes: "a", "abc" and "ca".
            The root node represents the empty string which all Tries will
            contain by default. Witness this Trie:
          </p>
          <div class="image-container">
            <img
              src="{{ url_for('static', filename='trie.jpg') }}"
              alt="A Trie"
            />
            <figcaption>A Trie with a small character set</figcaption>
          </div>

          <p>
            We can see a simple implementation with the following search bar:
          </p>
        </div>
        <div class="search-container">
          <form id="trie-form">
            <div id="trie-search-bar" class="search-bar">
              <input
                id="search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          This implementation is efficient. Suggestions are found in O(P+H*C*N)
          time. "P" represents the length of the prefix that we are trying to
          get suggestions for. "H" represents the height of the subtree we are
          trying to get suggestions from. This is the length of the longest
          suffix in the subtree. "C" represents the character set the Trie
          supports. In our implementation, the character set is 26 English
          letters + 1 space character = 27. "N" represents the number of
          suffixes the subtree contains.
        </p>
        <p>
          It is not neccesary to support strings of a potentially unlimited
          length. Most searches are short, so we can set a reasonable max height
          for our Trie. In our implementation, we chose 200 for the max length
          of a word in the Trie. Since "P", "H" and "C" are constants,
          retrieving autocomplete suggestions is done in O(N) time. "N" is also
          technically limited by the max size of the trie. Deletions and
          insertions are done in O(H) time which reduces to O(1).
        </p>
        <p>
          The main drawback of the Trie is the large amount of memory that is
          used. Every node has a number of children equal to the size of the
          character set. Generally, most of the children of a given node will be
          null pointers. The maximum size of a Trie is (C^(H+1)-1)/(C-1). For
          our implementation, C=27 and H=200 which gives us a maximum size of
          1.9 x 10^286 nodes. That is a very large constant. Without a fixed
          height or character set, the size of a Trie is O(C^H).
        </p>
        <p>
          The Trie will find all suggestions for our given prefix. We will need
          to limit the suggestions we show. One feature of the Trie is that all
          suggestions will be ouput in alphabetical order. Alphabetical order is
          not likely the most relevant. But how do we choose which suggestions
          to show?
        </p>
      </section>
      <section>
        <h2>A Weighted Trie</h2>
        <p>
          We can make some simple modifications to our Trie to add a weight to
          each suffix. People will generally be looking for the most commonly
          searched terms. Therefore, the weight of a node will represent how
          often that term has appeared in searches.
        </p>
        <p>
          The new weight property will also serve to determine if a node is the
          end of a suffix. Nodes with a weight 1 or greater represent the end of
          a suffix.
        </p>
        <p>Try the new search bar and compare the results from the original:</p>
        <div class="search-container">
          <form id="trie-weighted-form">
            <div id="trie-weighted-search-bar" class="search-bar">
              <input
                id="weighted-search-input"
                class="search"
                maxlength="200"
                type="text"
                name="search"
                autocapitalize="off"
                autocomplete="off"
                autocorrect="off"
                spellcheck="false"
                title="Search"
                value=""
              />
            </div>
            <div id="weighted-suggestions" class="auto-complete" hidden>
              <div class="auto-line"></div>
            </div>
          </form>
          <figcaption>
            Try me! (<b>Warning:</b> Some suggestions are NSFW)
          </figcaption>
        </div>
        <p>
          We see that suggestions are now sorted in descending order based on
          weight. This Weighted Trie acts almost identically to the original
          Trie, except now results will be sorted.
        </p>
        <p>
          Sorting our suggestions does slow down retrieval. We use Timsort - the
          default sorting algorithm in Python. Timsort is a good choice because
          the algorithm is stable. This means that it will automatically keep
          the previously existing alphabetical ordering after sorting by weight
          for items of equal weight.
        </p>
        <p>
          Timsort operates in O(N log N) time. "N" represents the number of
          suffixes that match our prefix. The number of suffixes found is
          limited by the maximum number of nodes that our Trie may contain. The
          preformance hit is well worth the benefit of drastically enhanced user
          experience.
        </p>
        <p>
          Now that our Trie is showing more relevant suggestions. What can we do
          to improve performance? Stay tuned to find out!
        </p>
      </section>
    </div>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
